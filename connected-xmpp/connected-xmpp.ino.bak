#include <SPI.h>
#include <MFRC522.h>
#include <ESP32Servo.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <WiFi.h>
#include <FirebaseESP32.h>
#include <time.h>
// Tambahkan library XMPP jika tersedia untuk ESP32 (pseudo, karena tidak ada library XMPP native ESP32)
// #include <XMPPClient.h> // Jika ada library XMPP untuk ESP32

// Pin konfigurasi
#define SS_PIN    5    // SDA pin RFID
#define RST_PIN   4   // RST pin RFID
#define SERVO_PIN 2   // Pin sinyal servo
#define LED_PIN   21   // Pin sinyal LED
#define LCD_ADDR 0x27 // Alamat I2C LCD, sesuaikan jika berbeda
#define LCD_COLS 16
#define LCD_ROWS 2

// Konfigurasi WiFi
#define WIFI_SSID "YOUR_WIFI_SSID" // Ganti dengan SSID WiFi Anda
#define WIFI_PASSWORD "YOUR_WIFI_PASSWORD" // Ganti dengan password WiFi Anda

// Konfigurasi Firebase
#define API_KEY "YOUR_API_KEY" // Ganti dengan API Key Firebase Anda
#define DATABASE_URL "https://your-database-url.firebaseio.com/" // Ganti dengan URL database Firebase Anda
#define USER_EMAIL "YOUR_EMAIL" // Ganti dengan email Firebase Anda
#define USER_PASSWORD "YOUR_PASSWORD" // Ganti dengan password Firebase Anda
FirebaseData firebaseData;
FirebaseAuth firebaseAuth;
FirebaseConfig firebaseConfig;

// Konfigurasi XMPP (pseudo, sesuaikan jika ada library XMPP untuk ESP32)
#define XMPP_JID "mnaufalmaulana84@xmpp.jp"
#define XMPP_PASSWORD "74njc#qYeKbXo8"
#define XMPP_SERVER "xmpp.jp"
#define XMPP_PORT 5222
// XMPPClient xmppClient(XMPP_JID, XMPP_PASSWORD, XMPP_SERVER, XMPP_PORT);

MFRC522 rfid(SS_PIN, RST_PIN);
Servo myServo;
LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);

// Untuk log lokal (array sederhana)R
#define MAX_LOG 20
struct LogEntry {
  String uid;
  String datetime;
};
LogEntry localLogs[MAX_LOG];
int logIndex = 0;

// Tambahan: Queue untuk log non-blocking
#define LOG_QUEUE_SIZE 10
struct LogQueueEntry {
  String uid;
  String datetime;
};
LogQueueEntry logQueue[LOG_QUEUE_SIZE];
int logQueueHead = 0;
int logQueueTail = 0;
bool firebaseBusy = false;

void connectWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  lcd.setCursor(0, 0);
  lcd.print("WiFi connecting...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  lcd.setCursor(0, 0);
  lcd.print("WiFi connected   ");
  Serial.println("WiFi connected");
}

void initFirebase() {
  firebaseConfig.api_key = API_KEY;
  firebaseConfig.database_url = DATABASE_URL;
  firebaseAuth.user.email = USER_EMAIL;
  firebaseAuth.user.password = USER_PASSWORD;
  Firebase.begin(&firebaseConfig, &firebaseAuth);
  Firebase.reconnectWiFi(true);
}

void setupTime() {
  configTime(7 * 3600, 0, "pool.ntp.org"); // GMT+7
  while (time(nullptr) < 100000) {
    delay(100);
  }
}

String getDateTime() {
  time_t now = time(nullptr);
  struct tm * timeinfo = localtime(&now);
  char buf[25];
  strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", timeinfo);
  return String(buf);
}

// Fungsi untuk menambah log ke queue
void enqueueLog(String uid, String datetime) {
  int nextTail = (logQueueTail + 1) % LOG_QUEUE_SIZE;
  if (nextTail != logQueueHead) { // Queue tidak penuh
    logQueue[logQueueTail].uid = uid;
    logQueue[logQueueTail].datetime = datetime;
    logQueueTail = nextTail;
  }
}

// Fungsi untuk mengirim log dari queue ke Firebase (non-blocking style)
void processLogQueue() {
  if (logQueueHead == logQueueTail || firebaseBusy) return; // Queue kosong atau sedang kirim
  String uid = logQueue[logQueueHead].uid;
  String datetime = logQueue[logQueueHead].datetime;
  String path = "/logs/";
  path.concat(String(millis()));
  String pathUid = path;
  pathUid.concat("/uid");
  String pathDatetime = path;
  pathDatetime.concat("/datetime");
  firebaseBusy = true;
  // Kirim log ke Firebase secara synchronous
  bool ok1 = Firebase.setString(firebaseData, pathUid.c_str(), uid);
  bool ok2 = Firebase.setString(firebaseData, pathDatetime.c_str(), datetime);
  firebaseBusy = false;
  logQueueHead = (logQueueHead + 1) % LOG_QUEUE_SIZE; // Hapus log dari queue setelah selesai
}

void saveLogLocal(String uid, String datetime) {
  if (logIndex < MAX_LOG) {
    localLogs[logIndex].uid = uid;
    localLogs[logIndex].datetime = datetime;
    logIndex++;
  }
}

void setup() {
  Serial.begin(115200);
  // Inisialisasi I2C dengan pin default ESP32 (SDA=21, SCL=22)
  Wire.begin(21, 22);
  // Inisialisasi LCD
  lcd.init();
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Sistem siap");
  lcd.setCursor(0, 1);
  lcd.print("Tempelkan kartu");

  // Inisialisasi Servo
  myServo.setPeriodHertz(50); // Set frekuensi PWM untuk servo
  myServo.attach(SERVO_PIN, 500, 2400); // Atur pin servo dan batas pulsa

  // Inisialisasi RFID
  SPI.begin();          // Inisialisasi SPI bus
  rfid.PCD_Init();      // Inisialisasi RFID
  Serial.println("Sistem siap. Tempelkan kartu RFID Anda.");

  pinMode(LED_PIN, OUTPUT);
  connectWiFi();
  initFirebase();
  setupTime();
}

void loop() {
  static bool waitingCard = true;
  static unsigned long lastStatusUpdate = 0;
  static String lastUID = "";

  if (waitingCard) {
    // Update LCD setiap 200ms, bukan setiap loop
    if (millis() - lastStatusUpdate > 200) {
      lcd.setCursor(0, 0);
      lcd.print("Menunggu kartu  ");
      lcd.setCursor(0, 1);
      lcd.print("                ");
      digitalWrite(LED_PIN, LOW);
      lastStatusUpdate = millis();
    }
  }

  // Check for new card
  if (rfid.PICC_IsNewCardPresent() && rfid.PICC_ReadCardSerial()) {
    waitingCard = false; // Stop "Menunggu kartu" updates from the block above
    digitalWrite(LED_PIN, HIGH);

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Membaca kartu   ");
    lcd.setCursor(0, 1);
    lcd.print("                ");
    delay(1000); // Increased delay to make "Membaca kartu" visible

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Kartu terdeteksi!");
    lcd.setCursor(0, 1);
    String uid = "";
    for (byte i = 0; i < rfid.uid.size; i++) {
      lcd.print(rfid.uid.uidByte[i], HEX);
      lcd.print(" ");
      uid += String(rfid.uid.uidByte[i], HEX);
      if (i < rfid.uid.size - 1) uid += ":";
    }
    Serial.print("UID terdeteksi: "); // Serial part is fine
    for (byte i = 0; i < rfid.uid.size; i++) {
      Serial.print(rfid.uid.uidByte[i] < 0x10 ? " 0" : " ");
      Serial.print(rfid.uid.uidByte[i], HEX);
    }
    Serial.println();
    delay(1500); // Increased delay to make "Kartu terdeteksi!" and UID visible

    myServo.write(180);
    delay(500); // Adjusted servo delay, was 200ms
    myServo.write(0);

    rfid.PICC_HaltA();
    rfid.PCD_StopCrypto1();
    digitalWrite(LED_PIN, LOW); // LED off after processing

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Sistem siap     "); // This will be on LCD during Firebase call
    lcd.setCursor(0, 1);
    lcd.print("Tempelkan kartu ");

    String datetime = getDateTime();
    enqueueLog(uid, datetime); // Masukkan log ke queue, tidak blocking
    saveLogLocal(uid, datetime);

    lastUID = uid;
    waitingCard = true; // Ready for next card, allow "Menunggu kartu" to be shown
    lastStatusUpdate = 0; // Force immediate update of "Menunggu kartu" in the next loop iteration
  }

  // Proses log queue ke Firebase (non-blocking)
  processLogQueue();
  delay(5); // Tambahkan delay kecil agar loop lebih ringan
}
